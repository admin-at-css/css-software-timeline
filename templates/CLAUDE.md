<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

*No recent activity*
</claude-mem-context>

# Instructions for Claude Code: Creating timeline.yaml

When asked to create a `timeline.yaml` file for this project, **DO NOT immediately ask the user questions**. You have access to the entire codebase - use it!

## Step 1: Explore the Codebase First

Before asking anything, gather information from:

1. **README.md** - Project name, description, purpose
2. **package.json / Cargo.toml / etc.** - Project metadata, dependencies, scripts
3. **Git history** - Run these commands:
   ```bash
   git log --oneline --reverse | head -1   # First commit = approximate start date
   git log --oneline | head -10            # Recent activity
   git log --format="%ad" --date=short | sort | uniq | wc -l  # Days with commits
   ```
4. **Git branches** - Check for feature branches (worktrees):
   ```bash
   git branch -a                           # List all branches (local + remote)
   git branch --list                       # Local branches only
   git branch -vv                          # Branches with last commit info
   ```
   **Interpreting branches:**
   - `feature/*` or `feat/*` branches = features in progress
   - `fix/*` or `bugfix/*` branches = bug fixes being worked on
   - Branches not merged to main = ongoing work (potential tasks)
   - Recently active branches = current focus areas

5. **Source code structure** - Identify major features/modules
6. **Existing documentation** - Any specs, design docs, or notes

## Step 2: Infer What You Can

From your exploration, determine:

| Field | How to Infer |
|-------|--------------|
| `id` | Repository/folder name, lowercase with dashes |
| `name` | From README title or package.json name |
| `description` | From README or package.json description |
| `status` | From code completeness: has tests? deployed? README says "WIP"? |
| `startDate` | First git commit date |
| `repository.url` | From `git remote -v` |
| `tasks` | From code structure, feature branches, and modules |

**Identify tasks from multiple sources:**
- **Code structure**: Major folders/modules = potential phases or features
- **Feature branches**: Each unmerged `feature/*` branch = task in progress
- **Merged branches**: Recently merged branches = completed tasks
- **Git log messages**: Patterns like "Add X", "Implement Y" reveal features

**Estimate hours based on codebase size:**
- Small project (<1000 LOC): 20-40 hours
- Medium project (1000-5000 LOC): 40-100 hours
- Large project (5000+ LOC): 100+ hours

**Estimate task progress based on:**
- Feature has tests = likely complete
- Feature has TODO comments = in progress
- Feature folder exists but empty/minimal = pending

## Step 3: Only Ask What You Cannot Determine

After exploring, you should ONLY need to ask:

1. **Priority level** - `critical` | `high` | `medium` | `low`
2. **Priority reason** - Why this priority? (for stakeholders)
3. **Target end date** - When should this ship? (if not already deployed)
4. **Actual hours spent** - Offer estimation OR manual input (see below)
5. **Corrections** - "I found X, Y, Z - is this accurate?"

### Handling Actual Hours (Interactive)

**Don't just ask "how many hours?"** - the user may not know. Instead, offer two options:

> **For actual hours spent, would you like me to:**
>
> **A) Estimate using industry best practices** - I'll calculate based on:
>    - Project complexity and codebase size
>    - Days with git commits × average focus hours
>    - Standard ratios for solo development work
>
> **B) Enter manually** - You provide the actual number
>
> Note: Hours include ALL work, not just coding:
> - Brainstorming & ideation
> - Research & learning
> - Planning & design
> - Coding & implementation
> - Testing & debugging
> - Documentation

**If user chooses Option A (Estimate), use this formula:**

```
Actual Hours = (Days with commits × Hours per active day) + Non-coding multiplier

Where:
- Days with commits = git log --format="%ad" --date=short | sort | uniq | wc -l
- Hours per active day = 3-4 hours (realistic for solo dev with other responsibilities)
- Non-coding multiplier = 1.5x (accounts for thinking, research, planning)

Example:
- 20 days with commits
- 3.5 hours average per day
- 1.5x multiplier for non-coding work
- Actual hours = 20 × 3.5 × 1.5 = 105 hours
```

**Additional estimation factors:**
- If project has complex integrations: add 20%
- If project required learning new tech: add 30%
- If project has documentation: add 10%
- If project started from scratch (no boilerplate): add 25%

**Example prompt after exploration:**

> I've analyzed the codebase and here's what I found:
>
> - **Project**: CSS Chrome Extension
> - **Description**: Browser extension for CSS team productivity
> - **Started**: November 15, 2024 (first commit)
> - **Status**: In progress (~70% complete based on code)
> - **Estimated total hours**: ~80 hours (based on codebase size)
>
> **Tasks I identified:**
> 1. Extension Setup (completed - manifest.json exists, basic structure done)
> 2. Core Features (in progress - popup and content scripts partially implemented)
> 3. Polish & Testing (pending - no tests yet)
>
> **I need from you:**
>
> 1. **Priority level?** (critical/high/medium/low)
>
> 2. **Why this priority?** (one sentence for stakeholders)
>
> 3. **Target completion date?**
>
> 4. **Actual hours spent so far:**
>    - **Option A**: I estimate ~52 hours based on 15 active days × 3.5 hrs × 1.0 (chrome extension is familiar tech). Want me to use this?
>    - **Option B**: Enter your own number

## Step 4: Create timeline.yaml

Choose the appropriate template:
- **`timeline-minimal.yaml`** - For idea/planning phase projects
- **`timeline-full.yaml`** - For active development with clear phases

Create `timeline.yaml` in the project root with:
- All inferred values filled in
- User-provided values for priority, hours, dates
- `metadata.lastUpdated` set to current ISO timestamp

## Step 5: Validate

Check that:
- [ ] All required fields present
- [ ] Dates in YYYY-MM-DD format
- [ ] Valid status/priority enum values
- [ ] At least one stakeholder (default: Kevin Zakaria, Developer)
- [ ] At least one task with valid dependencies
- [ ] Progress values 0-100

## Step 6: Clean Up Templates Folder

**IMPORTANT:** The `templates/` folder is a temporary tool - do NOT commit it to the project repo.

After creating `timeline.yaml`, clean up:

```bash
# Option A: Delete the templates folder (recommended)
rm -rf templates/

# Option B: Add to .gitignore if you want to keep it locally
echo "templates/" >> .gitignore
```

## Step 7: Commit Only timeline.yaml

```bash
git add timeline.yaml
git commit -m "Add timeline.yaml for CSS Software Timeline dashboard"
git push
```

**What gets committed:**
- `timeline.yaml` - YES, this is the project's timeline data

**What should NOT be committed:**
- `templates/` folder - NO, this is just a reference tool
- `templates/CLAUDE.md` - NO, instructions are only needed during creation

---

## Quick Reference

### Project Status
| Status | When to Use |
|--------|-------------|
| `draft` | Just an idea, no code yet |
| `planning` | Designing, no implementation |
| `in_progress` | Active development |
| `on_hold` | Paused |
| `completed` | Shipped/Done |
| `cancelled` | Abandoned |

### Task Status
| Status | Indicators |
|--------|------------|
| `pending` | Folder/file doesn't exist or is empty |
| `in_progress` | Has code but incomplete, TODOs present |
| `completed` | Feature works, has tests, no TODOs |
| `blocked` | Depends on external factor |

### Priority
| Level | Meaning |
|-------|---------|
| `critical` | Blocking other work, must ship ASAP |
| `high` | Important, prioritize this |
| `medium` | Normal priority |
| `low` | Nice to have, can wait |

---

## Key Principle

**You are an intelligent assistant with full codebase access. Act like it.**

Don't ask the user to describe their own code - read it yourself. Only ask for information that genuinely requires human input (priorities, business context, time spent).
